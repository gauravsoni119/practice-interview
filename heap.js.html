<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>heap.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html">AVLTree</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#.isSameTree">isSameTree</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#.isSubTree">isSubTree</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#getDiameter">getDiameter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#getHeight">getHeight</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#insert">insert</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#invert">invert</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_avl-tree-AVLTree.html#isBalanced">isBalanced</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_avl-tree-TreeNode.html">TreeNode</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_binary-tree-BinarySearchTree.html">BinarySearchTree</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_binary-tree-BinarySearchTree.html#.lowestCommonAncestor">lowestCommonAncestor</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_binary-tree-BinarySearchTree.html#insert">insert</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_binary-tree-TreeNode.html">TreeNode</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html">Heap</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html#.kthLargestElement">kthLargestElement</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html#.lastStoneWeight">lastStoneWeight</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html#add">add</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html#changeKey">changeKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_heap-Heap.html#extract">extract</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_linked-list-LinkedList.html">LinkedList</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_linked-list-LinkedList.html#.merge">merge</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_linked-list-LinkedList.html#recursiveReverse">recursiveReverse</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-ds_linked-list-LinkedList.html#reverse">reverse</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-ds_linked-list-ListNode.html">ListNode</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-ds_avl-tree.html">ds/avl-tree</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-ds_binary-tree.html">ds/binary-tree</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-ds_heap.html">ds/heap</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-ds_linked-list.html">ds/linked-list</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">heap.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**
 * &lt;b>Binary Heap&lt;/b>
 * A binary heap is the complete binary tree which satisfies the heap properties.
 *
 * @example
 * import { Heap } from '../../ds/heap';
 * const minHeap = new Heap&lt;number>((a, b) => b - a);
 * minHeap.add(5);
 * minHeap.add(2);
 * minHeap.add(3);
 * minHeap.add(7);
 *
 * console.log(minHeap.top); // 2
 * console.log(minHeap.extract()); // 3
 * console.log(minHeap.extract()); // 5
 *
 * @author Gaurav Soni
 *
 * @module ds/heap
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Heap = void 0;
/**
 * Heap
 *
 *
 * @public
 * @constructor
 */
class Heap {
    constructor(cmp) {
        this.heap = [];
        this.cmp = (a, b) => a - b;
        this.cmp = cmp ? cmp : this.cmp;
    }
    /**
     * Add the value into the heap. &lt;br />&lt;br />
     * &lt;b>Time Complexity:&lt;/b> O(logN).
     *
     * @public
     * @method
     * @param {T} value value that needs to be inserted
     * @returns void
     */
    add(value) {
        this.heap.push(value);
        this.changeKey(this.heap.length - 1, value);
    }
    /**
     * Remove the top most item from the heap. &lt;br />&lt;br />
     * &lt;b>Time Complexity:&lt;/b> O(logN).
     *
     * @public
     * @method
     * @returns {value} The top most item from the heap
     */
    extract() {
        if (!this.heap.length) {
            throw 'The heap is already empty!';
        }
        const removedItem = this.heap.shift();
        this.heapify(0);
        return removedItem;
    }
    /**
     * Getter to get the top most item in the heap
     */
    get top() {
        return this.heap[0];
    }
    /**
     * Getter to get the size of the heap
     */
    get size() {
        return this.heap.length;
    }
    /**
     * Change the value of the key. It will update the value according to the heap type(min/max). &lt;br />&lt;br />
     * &lt;b>Time Complexity:&lt;/b> O(logN).
     *
     * @public
     * @method
     * @returns {value} The top most item from the heap
     *
     */
    changeKey(index, value) {
        this.heap[index] = value;
        let parent = this.getParentIndex(index);
        while (parent >= 0 &amp;&amp;
            this.cmp(this.heap[index], this.heap[parent]) > 0) {
            this.swap(parent, index);
            index = parent;
            parent = this.getParentIndex(index);
        }
    }
    heapify(index) {
        let extra = index;
        while (index &lt; this.heap.length - 1) {
            const left = this.getLeftIndex(index);
            const right = this.getRightIndex(index);
            if (left &lt; this.heap.length &amp;&amp;
                this.cmp(this.heap[left], this.heap[index]) > 0) {
                extra = left;
            }
            if (right &lt; this.heap.length &amp;&amp;
                this.cmp(this.heap[right], this.heap[index]) > 0 &amp;&amp;
                this.cmp(this.heap[right], this.heap[left]) > 0) {
                extra = right;
            }
            if (extra !== index) {
                this.swap(index, extra);
                index = extra;
            }
            else {
                return;
            }
        }
    }
    getParentIndex(index) {
        return Math.floor((index - 1) / 2);
    }
    getLeftIndex(index) {
        return Math.floor(index * 2 + 1);
    }
    getRightIndex(index) {
        return Math.floor(index * 2 + 2);
    }
    swap(a, b) {
        [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
    }
    /**
     * Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
     * &lt;br />Implement KthLargest class:&lt;br />
     * KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
     * int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.
     * For example,
     * &lt;br />
     * &lt;b>Input:&lt;/b> ["KthLargest", "add", "add", "add", "add", "add"]
     * [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
     * &lt;br />
     * &lt;b>Output:&lt;/b> [null, 4, 5, 5, 8, 8]
     * &lt;br />
     * &lt;b>Time Complexity for constructor:&lt;/b> O(n*log(k)) &lt;br />
     * T&lt;b>ime Complexity for add function:&lt;/b> O(n*log(k))
     *
     * @method
     * @see {@link https://leetcode.com/problems/kth-largest-element-in-a-stream/|Kth Largest Element in a Stream}
     *
     * @public
     *
     * @param {number} k kth position of the element that needs to be returned
     * @param {number[]} nums Stream of numbers
     * @returns {Object} Object containing add method which will maintain the heap of 'k' size.
     */
    static kthLargestElement(k, nums) {
        const minHeap = new Heap((a, b) => b - a);
        for (const num of nums) {
            minHeap.add(num);
            if (minHeap.size > k) {
                minHeap.extract();
            }
        }
        return {
            add: (num) => {
                minHeap.add(num);
                if (minHeap.size > k) {
                    minHeap.extract();
                }
                return minHeap.top;
            }
        };
    }
    /**
     * You are given an array of integers stones where stones[i] is the weight of the ith stone.
     * &lt;br />Implement KthLargest class:&lt;br />
     * We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together.
     * Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: &lt;br />
     *  If x == y, both stones are destroyed, and &lt;br />
     *  If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
     * At the end of the game, there is at most one stone left.
     * Return the weight of the last remaining stone. If there are no stones left, return 0.
     * For example,
     * &lt;br />
     * &lt;b>Input:&lt;/b> stones = [2,7,4,1,8,1]
     * &lt;br />
     * &lt;b>Output:&lt;/b> 1
     * &lt;br />
     *
     * &lt;b>Time Complexity:&lt;/b> O(n*log(n)) &lt;br />
     *
     * @method
     * @see {@link https://leetcode.com/problems/last-stone-weight/|Last Stone Weight}
     *
     * @public
     *
     * @param {number[]} stones Stones where stones[i] is the weight of the ith stone.
     * @returns {number} Weight of the last remaining stone.
     */
    static lastStoneWeight(stones) {
        const maxHeap = new Heap();
        for (const stone of stones) {
            maxHeap.add(stone);
        }
        while (maxHeap.size > 1) {
            const x = maxHeap.extract();
            const y = maxHeap.extract();
            const diff = x - y;
            if (diff > 0) {
                maxHeap.add(diff);
            }
        }
        return maxHeap.size > 0 ? maxHeap.top : 0;
    }
}
exports.Heap = Heap;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sun Sep 11 2022 17:49:14 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
